<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  
  <title>CharlestonHacks Innovation Engine</title>
  <meta name="description" content="Making Invisible Networks Visible"/>
  
  <link rel="icon" href="favicon.ico"/>
  
  <!-- Your Existing CSS -->
  <link rel="stylesheet" href="assets/css/base.css" />
  <link rel="stylesheet" href="assets/css/engine.css" />
  <link rel="stylesheet" href="assets/css/overlays.css" />
  <link rel="stylesheet" href="assets/css/connections.css" />
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  
  <style>
    /* Enhanced Features Styles */
    .notification-toast {
      position: fixed;
      top: 80px;
      right: 20px;
      background: linear-gradient(135deg, #c9a35e, #d4b684);
      color: #000;
      padding: 1rem 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(201, 163, 94, 0.6);
      z-index: 10000;
      animation: slideInRight 0.3s ease;
      max-width: 350px;
      font-weight: 600;
    }

    @keyframes slideInRight {
      from { transform: translateX(400px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }

    .notification-toast.success { background: linear-gradient(135deg, #0f0, #0c0); }
    .notification-toast.error { background: linear-gradient(135deg, #f00, #c00); color: #fff; }
    .notification-toast.info { background: linear-gradient(135deg, #00e0ff, #00b8cc); }

    .online-pulse {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #0f0;
      display: inline-block;
      margin-left: 0.5rem;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; box-shadow: 0 0 5px #0f0; }
      50% { opacity: 0.5; box-shadow: 0 0 15px #0f0; }
    }

    .image-upload-container {
      width: 150px;
      height: 150px;
      border: 2px dashed #00e0ff;
      border-radius: 50%;
      overflow: hidden;
      cursor: pointer;
      position: relative;
      transition: all 0.3s ease;
    }

    .image-upload-container:hover {
      border-color: #c9a35e;
      transform: scale(1.05);
    }

    .image-upload-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .upload-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .image-upload-container:hover .upload-overlay {
      opacity: 1;
    }

    .filter-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin: 1rem 0;
    }

    .chip {
      background: rgba(0, 224, 255, 0.1);
      border: 1px solid #00e0ff;
      color: #00e0ff;
      padding: 0.4rem 1rem;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.85rem;
    }

    .chip:hover, .chip.active {
      background: #00e0ff;
      color: #000;
    }

    /* BBS Messaging */
    .bbs-grid {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 1.5rem;
      height: calc(100vh - 250px);
    }

    .channel-sidebar {
      background: rgba(10, 10, 10, 0.8);
      border: 1px solid rgba(0, 224, 255, 0.3);
      border-radius: 12px;
      padding: 1rem;
      overflow-y: auto;
    }

    .channel-item {
      padding: 0.8rem;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .channel-item:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .channel-item.active {
      background: rgba(0, 224, 255, 0.2);
      border-left: 3px solid #00e0ff;
    }

    .unread-badge {
      background: #c9a35e;
      color: #000;
      padding: 0.2rem 0.6rem;
      border-radius: 12px;
      font-size: 0.75rem;
      font-weight: bold;
    }

    .messages-panel {
      background: rgba(10, 10, 10, 0.8);
      border: 1px solid rgba(0, 224, 255, 0.3);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
    }

    .messages-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid rgba(0, 224, 255, 0.3);
      background: rgba(0, 0, 0, 0.5);
    }

    .messages-body {
      flex: 1;
      overflow-y: auto;
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .message {
      display: flex;
      gap: 1rem;
      align-items: flex-start;
    }

    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .message-content {
      flex: 1;
    }

    .message-author {
      font-weight: 600;
      color: #00e0ff;
      margin-bottom: 0.3rem;
      font-size: 0.9rem;
    }

    .message-text {
      color: #fff;
      line-height: 1.5;
    }

    .message-time {
      color: #888;
      font-size: 0.75rem;
      margin-top: 0.3rem;
    }

    .message-input-container {
      padding: 1rem 1.5rem;
      border-top: 1px solid rgba(0, 224, 255, 0.3);
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      gap: 0.8rem;
    }

    .message-input {
      flex: 1;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(0, 224, 255, 0.3);
      border-radius: 25px;
      color: #fff;
      padding: 0.8rem 1.2rem;
      font-family: inherit;
      font-size: 0.95rem;
    }

    .message-input:focus {
      outline: none;
      border-color: #00e0ff;
    }

    .typing-indicator {
      display: flex;
      gap: 0.4rem;
      padding: 0.5rem 1rem;
      color: #888;
      font-size: 0.85rem;
    }

    .typing-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #00e0ff;
      animation: typing 1.4s infinite;
    }

    .typing-dot:nth-child(2) { animation-delay: 0.2s; }
    .typing-dot:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.5; }
      30% { transform: translateY(-8px); opacity: 1; }
    }

    /* Synapse Network */
    #synapse-fullscreen {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.98);
      z-index: 10000;
      display: none;
    }

    #synapse-fullscreen.active {
      display: block;
    }

    .synapse-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 0.8rem;
      z-index: 10001;
    }

    .synapse-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.95);
      border: 2px solid #00e0ff;
      border-radius: 8px;
      padding: 1rem;
      color: #fff;
      pointer-events: none;
      display: none;
      z-index: 10002;
      min-width: 200px;
    }

    /* Analytics */
    .analytics-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 2rem;
      margin: 2rem 0;
    }

    .chart-card {
      background: rgba(10, 10, 10, 0.8);
      border: 1px solid rgba(0, 224, 255, 0.3);
      border-radius: 12px;
      padding: 2rem;
    }

    .chart-title {
      color: #00e0ff;
      font-size: 1.3rem;
      margin-bottom: 1.5rem;
      font-weight: 600;
    }

    /* Loading */
    .spinner {
      border: 3px solid rgba(0, 224, 255, 0.3);
      border-top: 3px solid #00e0ff;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
      margin: 2rem auto;
    }

    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Export FAB */
    .export-fab {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: linear-gradient(135deg, #c9a35e, #d4b684);
      color: #000;
      border: none;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(201, 163, 94, 0.6);
      font-size: 1.5rem;
      transition: all 0.3s ease;
      z-index: 9998;
      display: none;
    }

    .export-fab.visible {
      display: block;
    }

    .export-fab:hover {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 8px 30px rgba(201, 163, 94, 0.8);
    }

    /* Responsive */
    @media (max-width: 968px) {
      .bbs-grid {
        grid-template-columns: 1fr;
      }

      .channel-sidebar {
        max-height: 200px;
      }

      .analytics-grid {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  
  <!-- Notification Container -->
  <div id="notification-container"></div>

  <!-- Content will be managed by existing structure -->
  <!-- This file extends your current 2card with new features -->

  <!-- Synapse Fullscreen -->
  <div id="synapse-fullscreen">
    <div class="synapse-controls">
      <button class="action-btn" onclick="CharlestonApp.closeSynapse()">
        <i class="fas fa-times"></i> Close
      </button>
      <button class="action-btn" onclick="CharlestonApp.resetSynapse()">
        <i class="fas fa-compress"></i> Reset
      </button>
    </div>
    <svg id="synapse-svg" width="100%" height="100%"></svg>
    <div class="synapse-tooltip" id="synapse-tooltip"></div>
  </div>

  <!-- Export FAB -->
  <button class="export-fab" id="export-fab" title="Export as PDF">
    <i class="fas fa-file-pdf"></i>
  </button>

  <!-- External Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  
  <!-- Your Existing Supabase Client -->
  <script type="module">
    import { supabase } from "./assets/js/supabaseClient.js";
    window.supabase = supabase;
    console.log("%câœ“ Supabase Connected", "color:#0ff; font-weight:bold; font-size:14px");
  </script>

  <!-- Main Application -->
  <script type="module">
    // Wait for supabase to load
    const waitForSupabase = setInterval(() => {
      if (!window.supabase) return;
      clearInterval(waitForSupabase);
      initCharlestonApp();
    }, 100);

    function initCharlestonApp() {
      const supabase = window.supabase;
      
      // Global Application Object
      window.CharlestonApp = {
        user: null,
        profile: null,
        currentChannel: null,
        messageSubscription: null,
        presenceChannel: null,
        charts: {},

        // ===========================================
        // INITIALIZATION
        // ===========================================
        
        async init() {
          console.log('%cðŸš€ Initializing CharlestonHacks Innovation Engine', 'color:#c9a35e; font-weight:bold; font-size:16px');
          
          await this.checkAuth();
          this.setupGlobalListeners();
          
          // Enable realtime features
          if (this.user) {
            this.initPresence();
            this.initNotifications();
          }
        },

        async checkAuth() {
          const { data: { session } } = await supabase.auth.getSession();
          
          if (session?.user) {
            this.user = session.user;
            await this.loadProfile();
            this.showAuthUI();
          }
          
          // Auth state listener
          supabase.auth.onAuthStateChange(async (event, session) => {
            if (event === 'SIGNED_IN' && session) {
              this.user = session.user;
              await this.loadProfile();
              this.showAuthUI();
              this.initPresence();
            } else if (event === 'SIGNED_OUT') {
              location.reload();
            }
          });
        },

        async loadProfile() {
          const { data } = await supabase
            .from('community')
            .select('*')
            .eq('user_id', this.user.id)
            .single();
          
          if (data) {
            this.profile = data;
            this.populateProfileForm();
          }
        },

        showAuthUI() {
          console.log('âœ“ User authenticated:', this.user.email);
          // Your existing auth UI logic
        },

        // ===========================================
        // PHASE 1: PROFILE IMAGE UPLOAD
        // ===========================================
        
        async uploadProfileImage(file) {
          if (!file) return null;
          
          // Validate
          if (file.size > 2 * 1024 * 1024) {
            this.notify('Image too large. Max 2MB', 'error');
            return null;
          }

          const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
          if (!allowedTypes.includes(file.type)) {
            this.notify('Invalid file type. Use JPG, PNG, or GIF', 'error');
            return null;
          }

          // Show progress
          const progressEl = document.getElementById('upload-progress');
          if (progressEl) progressEl.classList.remove('hidden');

          try {
            const fileExt = file.name.split('.').pop();
            const fileName = `${this.user.id}-${Date.now()}.${fileExt}`;
            const filePath = `profiles/${fileName}`;

            // Upload to Supabase Storage
            const { data, error } = await supabase.storage
              .from('hacksbucket')
              .upload(filePath, file, {
                cacheControl: '3600',
                upsert: true
              });

            if (error) throw error;

            // Get public URL
            const { data: { publicUrl } } = supabase.storage
              .from('hacksbucket')
              .getPublicUrl(filePath);

            // Update database
            await supabase
              .from('community')
              .update({ image_url: publicUrl })
              .eq('user_id', this.user.id);

            this.profile.image_url = publicUrl;
            
            // Update UI
            const img = document.getElementById('profile-image-display');
            if (img) img.src = publicUrl;

            this.notify('Profile picture updated!', 'success');
            
            return publicUrl;

          } catch (error) {
            console.error('Upload error:', error);
            this.notify('Upload failed: ' + error.message, 'error');
            return null;
          } finally {
            if (progressEl) progressEl.classList.add('hidden');
          }
        },

        populateProfileForm() {
          // Auto-fill profile form with existing data
          const fields = {
            'profile-image-display': this.profile.image_url || 'https://via.placeholder.com/150',
            'first-name': this.profile.name?.split(' ')[0] || '',
            'last-name': this.profile.name?.split(' ').slice(1).join(' ') || '',
            'email': this.profile.email || this.user.email,
            'skills-input': this.profile.skills?.join(', ') || '',
            'bio-input': this.profile.bio || '',
            'availability-input': this.profile.availability || 'Available'
          };

          Object.entries(fields).forEach(([id, value]) => {
            const el = document.getElementById(id);
            if (!el) return;
            
            if (el.tagName === 'IMG') {
              el.src = value;
            } else {
              el.value = value;
            }
          });
        },

        // ===========================================
        // PHASE 1: SEARCH & FILTERS
        // ===========================================
        
        async filterProjects(options = {}) {
          const {
            search = '',
            status = 'all',
            sort = 'newest',
            tags = []
          } = options;

          let query = supabase
            .from('projects')
            .select('*');

          // Status filter
          if (status !== 'all') {
            query = query.eq('status', status);
          }

          // Search filter
          if (search) {
            query = query.or(`title.ilike.%${search}%,description.ilike.%${search}%`);
          }

          // Tag filter
          if (tags.length > 0) {
            query = query.contains('tags', tags);
          }

          // Sorting
          switch (sort) {
            case 'newest':
              query = query.order('created_at', { ascending: false });
              break;
            case 'oldest':
              query = query.order('created_at', { ascending: true });
              break;
            case 'most-bids':
              query = query.order('bid_count', { ascending: false });
              break;
            case 'most-upvotes':
              query = query.order('upvote_count', { ascending: false });
              break;
          }

          const { data, error } = await query;

          if (error) {
            console.error('Filter error:', error);
            return [];
          }

          return data;
        },

        setupProjectFilters() {
          // Search with debounce
          let searchTimeout;
          const searchInput = document.getElementById('project-search-input');
          if (searchInput) {
            searchInput.addEventListener('input', (e) => {
              clearTimeout(searchTimeout);
              searchTimeout = setTimeout(() => {
                this.refreshProjects();
              }, 300);
            });
          }

          // Status filter
          const statusFilter = document.getElementById('project-status-filter');
          if (statusFilter) {
            statusFilter.addEventListener('change', () => {
              this.refreshProjects();
            });
          }

          // Sort select
          const sortSelect = document.getElementById('project-sort-select');
          if (sortSelect) {
            sortSelect.addEventListener('change', () => {
              this.refreshProjects();
            });
          }
        },

        async refreshProjects() {
          const search = document.getElementById('project-search-input')?.value || '';
          const status = document.getElementById('project-status-filter')?.value || 'all';
          const sort = document.getElementById('project-sort-select')?.value || 'newest';
          
          const projects = await this.filterProjects({ search, status, sort });
          this.renderProjects(projects);
        },

        renderProjects(projects) {
          // Your existing project rendering logic
          console.log('Rendering', projects.length, 'projects');
        },

        // ===========================================
        // PHASE 2: REAL-TIME BBS MESSAGING
        // ===========================================
        
        async loadChannels() {
          const { data: channels } = await supabase
            .from('bbs_channels')
            .select('*')
            .order('name');

          return channels || [];
        },

        async selectChannel(channelId) {
          // Unsubscribe from previous
          if (this.messageSubscription) {
            supabase.removeChannel(this.messageSubscription);
          }

          this.currentChannel = channelId;

          // Load messages
          const { data: messages } = await supabase
            .from('bbs_messages')
            .select(`
              *,
              community!bbs_messages_user_id_fkey (name, email, image_url)
            `)
            .eq('channel_id', channelId)
            .order('created_at', { ascending: true })
            .limit(50);

          this.renderMessages(messages || []);

          // Subscribe to new messages
          this.messageSubscription = supabase
            .channel(`messages:${channelId}`)
            .on('postgres_changes', {
              event: 'INSERT',
              schema: 'public',
              table: 'bbs_messages',
              filter: `channel_id=eq.${channelId}`
            }, async (payload) => {
              // Fetch user data
              const { data: user } = await supabase
                .from('community')
                .select('name, email, image_url')
                .eq('user_id', payload.new.user_id)
                .single();

              this.appendMessage({
                ...payload.new,
                community: user
              });
            })
            .subscribe();
        },

        renderMessages(messages) {
          const container = document.getElementById('messages-display');
          if (!container) return;

          container.innerHTML = messages.map(msg => `
            <div class="message">
              <img class="message-avatar" src="${msg.community?.image_url || 'https://via.placeholder.com/40'}" alt="">
              <div class="message-content">
                <div class="message-author">${msg.community?.name || msg.community?.email || 'User'}</div>
                <div class="message-text">${this.escapeHtml(msg.text)}</div>
                <div class="message-time">${this.formatTime(msg.created_at)}</div>
              </div>
            </div>
          `).join('');

          // Scroll to bottom
          container.scrollTop = container.scrollHeight;
        },

        appendMessage(message) {
          const container = document.getElementById('messages-display');
          if (!container) return;

          const msgEl = document.createElement('div');
          msgEl.className = 'message';
          msgEl.innerHTML = `
            <img class="message-avatar" src="${message.community?.image_url || 'https://via.placeholder.com/40'}" alt="">
            <div class="message-content">
              <div class="message-author">${message.community?.name || message.community?.email || 'User'}</div>
              <div class="message-text">${this.escapeHtml(message.text)}</div>
              <div class="message-time">${this.formatTime(message.created_at)}</div>
            </div>
          `;

          container.appendChild(msgEl);
          container.scrollTop = container.scrollHeight;
        },

        async sendMessage(text) {
          if (!text.trim() || !this.currentChannel) return;

          const { error } = await supabase
            .from('bbs_messages')
            .insert([{
              channel_id: this.currentChannel,
              user_id: this.user.id,
              text: text.trim()
            }]);

          if (error) {
            console.error('Send error:', error);
            this.notify('Failed to send message', 'error');
          }
        },

        // ===========================================
        // PHASE 2: PRESENCE & TYPING INDICATORS
        // ===========================================
        
        initPresence() {
          this.presenceChannel = supabase.channel('online-users');
          
          this.presenceChannel
            .on('presence', { event: 'sync' }, () => {
              const state = this.presenceChannel.presenceState();
              console.log('Online users:', Object.keys(state).length);
              
              // Show online indicator
              const indicator = document.getElementById('online-indicator');
              if (indicator) indicator.classList.remove('hidden');
            })
            .on('presence', { event: 'join' }, ({ key, newPresences }) => {
              console.log('User joined:', key);
            })
            .on('presence', { event: 'leave' }, ({ key, leftPresences }) => {
              console.log('User left:', key);
            })
            .subscribe(async (status) => {
              if (status === 'SUBSCRIBED') {
                await this.presenceChannel.track({
                  user_id: this.user.id,
                  email: this.user.email,
                  online_at: new Date().toISOString()
                });
              }
            });
        },

        // ===========================================
        // PHASE 3: SYNAPSE NETWORK (D3.js)
        // ===========================================
        
        async launchSynapse() {
          document.getElementById('synapse-fullscreen').classList.add('active');
          await this.renderSynapse();
        },

        closeSynapse() {
          document.getElementById('synapse-fullscreen').classList.remove('active');
        },

        async renderSynapse() {
          // Fetch data
          const [people, projects, connections] = await Promise.all([
            supabase.from('community').select('id, name, skills, user_id'),
            supabase.from('projects').select('id, title, required_skills'),
            supabase.from('connections').select('from_user_id, to_user_id').eq('status', 'accepted')
          ]);

          // Build nodes
          const nodes = [
            ...(people.data || []).map(p => ({
              id: p.user_id,
              name: p.name,
              type: 'person',
              skills: p.skills
            })),
            ...(projects.data || []).map(p => ({
              id: p.id,
              name: p.title,
              type: 'project',
              skills: p.required_skills
            }))
          ];

          // Build links
          const links = (connections.data || []).map(c => ({
            source: c.from_user_id,
            target: c.to_user_id
          }));

          // D3 Force Simulation
          const svg = d3.select('#synapse-svg');
          const width = window.innerWidth;
          const height = window.innerHeight;

          svg.selectAll('*').remove();

          const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(links).id(d => d.id).distance(100))
            .force('charge', d3.forceManyBody().strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2));

          const link = svg.append('g')
            .selectAll('line')
            .data(links)
            .enter().append('line')
            .attr('stroke', '#00e0ff')
            .attr('stroke-opacity', 0.3)
            .attr('stroke-width', 2);

          const node = svg.append('g')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 10)
            .attr('fill', d => d.type === 'person' ? '#00e0ff' : '#c9a35e')
            .call(d3.drag()
              .on('start', dragstarted)
              .on('drag', dragged)
              .on('end', dragended))
            .on('click', (event, d) => {
              this.showSynapseTooltip(event, d);
            });

          simulation.on('tick', () => {
            link
              .attr('x1', d => d.source.x)
              .attr('y1', d => d.source.y)
              .attr('x2', d => d.target.x)
              .attr('y2', d => d.target.y);

            node
              .attr('cx', d => d.x)
              .attr('cy', d => d.y);
          });

          function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
          }

          function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
          }

          function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
          }
        },

        showSynapseTooltip(event, data) {
          const tooltip = document.getElementById('synapse-tooltip');
          tooltip.style.display = 'block';
          tooltip.style.left = event.pageX + 10 + 'px';
          tooltip.style.top = event.pageY + 10 + 'px';
          tooltip.innerHTML = `
            <strong>${data.name}</strong><br>
            Type: ${data.type}<br>
            ${data.skills ? 'Skills: ' + data.skills.join(', ') : ''}
          `;

          setTimeout(() => {
            tooltip.style.display = 'none';
          }, 3000);
        },

        resetSynapse() {
          this.renderSynapse();
        },

        // ===========================================
        // PHASE 3: ANALYTICS (Chart.js)
        // ===========================================
        
        async loadAnalytics() {
          // Projects over time
          const { data: projects } = await supabase
            .from('projects')
            .select('created_at')
            .order('created_at');

          if (projects) {
            const grouped = this.groupByMonth(projects);
            this.renderChart('projects-timeline-chart', 'line', {
              labels: grouped.labels,
              datasets: [{
                label: 'Projects Created',
                data: grouped.counts,
                borderColor: '#00e0ff',
                backgroundColor: 'rgba(0, 224, 255, 0.1)',
                fill: true
              }]
            });
          }

          // More charts...
          await this.loadConnectionsChart();
          await this.loadSkillsChart();
          await this.loadBidsChart();
        },

        groupByMonth(data) {
          const months = {};
          data.forEach(item => {
            const month = new Date(item.created_at).toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
            months[month] = (months[month] || 0) + 1;
          });

          return {
            labels: Object.keys(months),
            counts: Object.values(months)
          };
        },

        renderChart(canvasId, type, data) {
          const ctx = document.getElementById(canvasId);
          if (!ctx) return;

          if (this.charts[canvasId]) {
            this.charts[canvasId].destroy();
          }

          this.charts[canvasId] = new Chart(ctx, {
            type,
            data,
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  labels: {
                    color: '#fff'
                  }
                }
              },
              scales: type !== 'doughnut' ? {
                y: {
                  ticks: { color: '#fff' },
                  grid: { color: 'rgba(255, 255, 255, 0.1)' }
                },
                x: {
                  ticks: { color: '#fff' },
                  grid: { color: 'rgba(255, 255, 255, 0.1)' }
                }
              } : {}
            }
          });
        },

        async loadConnectionsChart() {
          // Implementation similar to projects chart
        },

        async loadSkillsChart() {
          // Implementation for skills bar chart
        },

        async loadBidsChart() {
          // Implementation for bids doughnut chart
        },

        // ===========================================
        // PHASE 3: EXPORT PDF
        // ===========================================
        
        async exportWorkflowPDF(projectId) {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();

          // Fetch project data
          const { data: project } = await supabase
            .from('projects')
            .select('*, cynq_cards(*)')
            .eq('id', projectId)
            .single();

          if (!project) return;

          // Build PDF
          doc.setFontSize(20);
          doc.text(project.title, 10, 10);
          
          doc.setFontSize(12);
          doc.text('CYNQ Workflow Export', 10, 20);
          
          let y = 30;
          const stages = ['empathize', 'define', 'ideate', 'prototype', 'test'];
          
          stages.forEach(stage => {
            const cards = project.cynq_cards.filter(c => c.stage === stage);
            
            doc.setFontSize(14);
            doc.text(stage.toUpperCase(), 10, y);
            y += 10;
            
            doc.setFontSize(10);
            cards.forEach(card => {
              doc.text(`â€¢ ${card.title}`, 15, y);
              y += 7;
            });
            
            y += 5;
          });

          doc.save(`${project.title}-workflow.pdf`);
          this.notify('PDF exported!', 'success');
        },

        // ===========================================
        // UTILITIES
        // ===========================================
        
        notify(message, type = 'info') {
          const toast = document.createElement('div');
          toast.className = `notification-toast ${type}`;
          toast.innerHTML = `
            <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"></i>
            ${message}
          `;
          
          document.getElementById('notification-container').appendChild(toast);
          
          setTimeout(() => {
            toast.style.animation = 'slideInRight 0.3s ease reverse';
            setTimeout(() => toast.remove(), 300);
          }, 3000);
        },

        escapeHtml(text) {
          const div = document.createElement('div');
          div.textContent = text;
          return div.innerHTML;
        },

        formatTime(timestamp) {
          const date = new Date(timestamp);
          const now = new Date();
          const diff = now - date;

          if (diff < 60000) return 'just now';
          if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
          if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
          
          return date.toLocaleDateString();
        },

        initNotifications() {
          // Request notification permission
          if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
          }
        },

        // ===========================================
        // EVENT LISTENERS
        // ===========================================
        
        setupGlobalListeners() {
          // Profile image upload
          const imageInput = document.getElementById('profile-photo-input');
          if (imageInput) {
            imageInput.addEventListener('change', async (e) => {
              const file = e.target.files[0];
              if (file) {
                await this.uploadProfileImage(file);
              }
            });
          }

          // Message input
          const messageInput = document.getElementById('message-input-field');
          const sendBtn = document.getElementById('send-message-btn');
          
          if (messageInput) {
            messageInput.addEventListener('keypress', (e) => {
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                this.sendMessage(messageInput.value);
                messageInput.value = '';
              }
            });
          }

          if (sendBtn) {
            sendBtn.addEventListener('click', () => {
              this.sendMessage(messageInput.value);
              messageInput.value = '';
            });
          }

          // Project filters
          this.setupProjectFilters();

          // Export FAB
          const exportBtn = document.getElementById('export-fab');
          if (exportBtn) {
            exportBtn.addEventListener('click', () => {
              const projectId = new URLSearchParams(window.location.search).get('project');
              if (projectId) {
                this.exportWorkflowPDF(projectId);
              }
            });
          }
        }
      };

      // Initialize
      window.CharlestonApp.init();
      
      console.log('%câœ¨ All features loaded!', 'color:#c9a35e; font-weight:bold; font-size:16px');
      console.log('%cðŸ“¦ Phase 1: Profile uploads, filters, loading states', 'color:#0ff');
      console.log('%câš¡ Phase 2: Real-time messaging, presence, notifications', 'color:#0ff');
      console.log('%cðŸŽ¨ Phase 3: Synapse network, analytics, PDF export', 'color:#0ff');
    }
  </script>

  <!-- Your Existing Main JS -->
  <script type="module" src="assets/js/main.js"></script>
  <script type="module" src="assets/js/neuralBackground.js"></script>
  <script type="module" src="assets/js/enhancements.js"></script>
</body>
</html>
